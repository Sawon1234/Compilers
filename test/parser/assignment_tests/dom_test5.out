interface List < E > extends Thing { fun elements < > ( ) : Iterable < E > ; } class Nil < > ( ) extends List < Nothing > { super ( ) ; fun elements < > ( ) : Iterable < Nothing > { return [ ] ; } } class Cons < E > ( head : E , tail : List < E > ) extends List < Nothing > { elems := [ head ] ++ tail . elements < > ( ) ; super ( ) ; fun elements < > ( ) : Iterable < E > { return elems ; } } l := Cons < Int < > > ( 3 , Cons < Int < > > ( 2 , Cons < Int < > > ( 1 , Nil < > ( ) ) ) ) ; for ( i in l ) { monad := Printer < > ( ) ; }